/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2022 DeNA Co., Ltd.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef MOV_ATOM_H_
#define MOV_ATOM_H_

#include <stddef.h>
#include "../base/cpu.h"

namespace mov {

struct VideoSampleDescription;
  
/**
 * Generates a FourCC code. (This macro actually generates FourCC codes stored
 * in memory so this library can compare FourCC codes generated by this macro
 * with ones stored in memory without byte-order conversions.)
 * @param {uint8_t} a
 * @param {uint8_t} b
 * @param {uint8_t} c
 * @param {uint8_t} d
 * @return {uint32_t}
 * @define
 */
#ifndef MOV_FOURCC
#if _BYTE_ORDER == _LITTLE_ENDIAN
#define MOV_FOURCC(a, b, c, d) ((a) | ((b) << 8) | ((c) << 16) | ((d) << 24))
#else
#define MOV_FOURCC(a, b, c, d) (((a) << 24) | ((b) << 16) | ((c) << 8) | (d))
#endif
#endif

/**
 * FourCC codes.
 * @enum
 */
enum FourCC {
  // Atom Types.
  TYPE_FTYP = MOV_FOURCC('f', 't', 'y', 'p'),        // File Type
  TYPE_MDAT = MOV_FOURCC('m', 'd', 'a', 't'),        // Movie sample data
  TYPE_MOOV = MOV_FOURCC('m', 'o', 'o', 'v'),        // Movie
  TYPE_FREE = MOV_FOURCC('f', 'r', 'e', 'e'),        // Free
  TYPE_SKIP = MOV_FOURCC('s', 'k', 'i', 'p'),        // Skip
  TYPE_WIDE = MOV_FOURCC('w', 'i', 'd', 'e'),        // Wide
  TYPE_PNOT = MOV_FOURCC('p', 'n', 'o', 't'),        // Preview

  // Movie atom
  TYPE_PRFL = MOV_FOURCC('p', 'r', 'f', 'l'),        // Profile
  TYPE_MVHD = MOV_FOURCC('m', 'v', 'h', 'd'),        // Movie header
  TYPE_CLIP = MOV_FOURCC('c', 'l', 'i', 'p'),        // Clipping
  TYPE_TRAK = MOV_FOURCC('t', 'r', 'a', 'k'),        // Track
  TYPE_UDTA = MOV_FOURCC('u', 'd', 't', 'a'),        // User data
  TYPE_CTAB = MOV_FOURCC('c', 't', 'a', 'b'),        // Color table
  TYPE_CMOV = MOV_FOURCC('c', 'm', 'o', 'v'),        // Compressed movie
  TYPE_RMRA = MOV_FOURCC('r', 'm', 'r', 'a'),        // Reference movie

  // Track Atom
  TYPE_TKHD = MOV_FOURCC('t', 'k', 'h', 'd'),        // Track header
  TYPE_TAPT = MOV_FOURCC('t', 'a', 'p', 't'),        // Track aperture
  TYPE_MATT = MOV_FOURCC('m', 'a', 't', 't'),        // Track matte
  TYPE_EDTS = MOV_FOURCC('e', 'd', 't', 's'),        // Edit
  TYPE_TREF = MOV_FOURCC('t', 'r', 'e', 'f'),        // Track reference
  TYPE_TXAS = MOV_FOURCC('t', 'x', 'a', 's'),        // Track exclude from auto-selection
  TYPE_LOAD = MOV_FOURCC('l', 'o', 'a', 'd'),        // Track load settings
  TYPE_IMAP = MOV_FOURCC('i', 'm', 'a', 'p'),        // Track input map
  TYPE_MDIA = MOV_FOURCC('m', 'd', 'i', 'a'),        // Media

  // Media Atom
  TYPE_MDHD = MOV_FOURCC('m', 'd', 'h', 'd'),        // Media header
  TYPE_ELNG = MOV_FOURCC('e', 'l', 'n', 'g'),        // Extended language tag
  TYPE_HDLR = MOV_FOURCC('h', 'd', 'l', 'r'),        // Handler reference
  TYPE_MINF = MOV_FOURCC('m', 'i', 'n', 'f'),        // Media information

  // Media Information Atom
  TYPE_VMHD = MOV_FOURCC('v', 'm', 'h', 'd'),        // Video media information
  TYPE_DINF = MOV_FOURCC('d', 'i', 'n', 'f'),        // Data information
  TYPE_STBL = MOV_FOURCC('s', 't', 'b', 'l'),        // Sample table

  // Sample Table Atom
  TYPE_STSD = MOV_FOURCC('s', 't', 's', 'd'),        // Sample description
  TYPE_STTS = MOV_FOURCC('s', 't', 't', 's'),        // Time-to-sample
  TYPE_CTTS = MOV_FOURCC('c', 't', 't', 's'),        // Composition offset
  TYPE_CSLG = MOV_FOURCC('c', 's', 'l', 'g'),        // Composition Shift Least Greatest
  TYPE_STSS = MOV_FOURCC('s', 't', 's', 's'),        // Sync sample
  TYPE_STPS = MOV_FOURCC('s', 't', 'p', 's'),        // Partial sync sample
  TYPE_STSC = MOV_FOURCC('s', 't', 's', 'c'),        // Sample-to-chunk
  TYPE_STSZ = MOV_FOURCC('s', 't', 's', 'z'),        // Sample size
  TYPE_STCO = MOV_FOURCC('s', 't', 'c', 'o'),        // Chunk offset
  TYPE_SDTP = MOV_FOURCC('s', 'd', 't', 'p'),        // Sample Dependency Flags
  TYPE_STSH = MOV_FOURCC('s', 't', 's', 'h'),        // Shadow sync

  // Brand IDs
  BRAND_QUICKTIME = MOV_FOURCC('q', 't', ' ', ' '),  // QuickTime

  // Vendor IDs
  VENDOR_APPL = MOV_FOURCC('a', 'p', 'p', 'l'),      // Apple
  VENDOR_FFMP = MOV_FOURCC('F', 'F', 'M', 'P'),      // FFmpeg

  // Video Sample Formats
  FORMAT_CVID = MOV_FOURCC('c', 'v', 'i', 'd'),      // Cinepak
  FORMAT_JPEG = MOV_FOURCC('j', 'p', 'e', 'g'),      // JPEG
  FORMAT_SMC  = MOV_FOURCC('s', 'm', 'c', ' '),      // Graphics
  FORMAT_RLE  = MOV_FOURCC('e', 'l', 'e', ' '),      // Animation
  FORMAT_RPZA = MOV_FOURCC('r', 'p', 'z', 'a'),      // Apple video
  FORMAT_KPCD = MOV_FOURCC('k', 'p', 'c', 'd'),      // Kodak Photo CD
  FORMAT_PNG  = MOV_FOURCC('p', 'n', 'g', ' '),      // Portable Network Graphics
  FORMAT_MJPA = MOV_FOURCC('m', 'j', 'p', 'a'),      // Motion-JPEG (format A)
  FORMAT_MJPB = MOV_FOURCC('m', 'j', 'p', 'b'),      // Motion-JPEG (format B)
  FORMAT_SVQ1 = MOV_FOURCC('S', 'V', 'Q', '1'),      // Sorenson video, version 1
  FORMAT_SVQ3 = MOV_FOURCC('S', 'V', 'Q', '3'),      // Sorenson video 3
  FORMAT_MP4V = MOV_FOURCC('m', 'p', '4', 'v'),      // MPEG-4 video
  FORMAT_AVC1 = MOV_FOURCC('a', 'v', 'c', '1'),      // AVC (H.264) video
  FORMAT_DVC  = MOV_FOURCC('d', 'v', 'c', ' '),      // NTSC DV-25 video
  FORMAT_DVCP = MOV_FOURCC('d', 'v', 'c', 'p'),      // PAL DV-25 video
  FORMAT_GIF  = MOV_FOURCC('g', 'i', 'f', ' '),      // CompuServe Graphics Interchange Format
  FORMAT_H263 = MOV_FOURCC('h', '2', '6', '3'),      // H.263 video
  FORMAT_HVC1 = MOV_FOURCC('h', 'v', 'c', '1'),      // HEVC (H.265) video
  FORMAT_TIFF = MOV_FOURCC('t', 'i', 'f', 'f'),      // Tagged Image File Format
  FORMAT_RAW  = MOV_FOURCC('r', 'a', 'w', ' '),      // Uncompressed RGB
  FORMAT_2VUY = MOV_FOURCC('2', 'y', 'u', 'Y'),      // Uncompressed YCbCr, 8-bit-per-component 4:2:2
  FORMAT_YUV2 = MOV_FOURCC('y', 'u', 'v', '2'),      // Uncompressed YCbCr, 8-bit-per-component 4:2:2
  FORMAT_V308 = MOV_FOURCC('v', '3', '0', '8'),      // Uncompressed YCbCr, 8-bit-per-component 4:4:4
  FORMAT_V408 = MOV_FOURCC('v', '4', '0', '8'),      // Uncompressed YCbCr, 8-bit-per-component 4:4:4:4
  FORMAT_V216 = MOV_FOURCC('v', '2', '1', '6'),      // Uncompressed YCbCr, 10, 12, 14, or 16-bit-per-component 4:2:2
  FORMAT_V410 = MOV_FOURCC('v', '4', '1', '0'),      // Uncompressed YCbCr, 10-bit-per-component 4:4:4
  FORMAT_V210 = MOV_FOURCC('v', '2', '1', '0'),      // Uncompressed YCbCr, 10-bit-per-component 4:2:2

  // Video Sample Description Extensions
  EXTENSION_GAMA = MOV_FOURCC('g', 'a', 'm', 'a'),   // Gamma Level
  EXTENSION_FIEL = MOV_FOURCC('f', 'i', 'e', 'l'),   // Field Handling
  EXTENSION_MJQT = MOV_FOURCC('m', 'j', 'q', 't'),   // The default quantization table for a Motion-JPEG video stream.
  EXTENSION_MJHT = MOV_FOURCC('m', 'j', 'h', 't'),   // The default Huffman table for a Motion-JPEG video stream.
  EXTENSION_ESDS = MOV_FOURCC('f', 'i', 'e', 'l'),   // MPEG-4 Elementary Stream Descriptor
  EXTENSION_AVCC = MOV_FOURCC('a', 'v', 'c', 'C'),   // H.264 AVC Decoder Configuration
  EXTENSION_PASP = MOV_FOURCC('p', 'a', 's', 'p'),   // Pixel Aspect Ratio
  EXTENSION_COLR = MOV_FOURCC('c', 'o', 'l', 'r'),   // Color Parameters
  EXTENSION_CLAP = MOV_FOURCC('c', 'l', 'a', 'p'),   // Clean Aperture
  EXTENSION_HVCC = MOV_FOURCC('h', 'v', 'c', 'C'),   // H.265 HEVC Decoder Configuration
};

// Prevent compilers from adding padding bytes to atoms.
#pragma pack(push, 1)

/**
 * The class that represents a QuickTime atom. A QuickTime atom is a chunk
 * object starting with an eight-byte header listed below. A QuickTime atom
 * stores its words in the most-significant-byte first order, i.e. little-endian
 * CPUs (e.g. x86 and ARM) have to swap their byte orders to read them.
 *   +------+----------------------+
 *   | size | field                |
 *   +------+----------------------+
 *   | 4    | size                 |
 *   | 4    | type                 |
 *   +------+----------------------+
 *   |      | type-specific data   |
 *   +------+----------------------+
 */
struct Atom {
  /**
   * Returns the start of this atom.
   * @return {uint32_t}
   * @public
   */
  const uint8_t* GetData() const {
    return reinterpret_cast<const uint8_t*>(this);
  }

  /**
   * Returns the size of this atom.
   * @return {uint32_t}
   * @public
   */
  uint32_t GetSize() const {
    return CPU::LoadUINT32BE(&size_);
  }

  /**
   * Returns the type of this atom.
   * @return {mov::FourCC}
   * @public
   */
  FourCC GetType() const {
    return static_cast<FourCC>(CPU::LoadUINT32(&type_));
  }

  /**
   * Returns the next atom.
   * @return {uint8_t*}
   * @public
   */
  const uint8_t* GetNext() const {
    const uint8_t* data = GetData();
    const uint32_t size = GetSize();
    return &data[size];
  }

  /**
   * The atom size.
   * @type {uint32_t}
   * @private
   */
  uint32_t size_;

  /**
   * The atom type.
   * @type {uint32_t}
   * @private
   */
  uint32_t type_;
};

/**
 * The class that represents a QuickTime File-Type atom, a variable-length
 * QuickTime atom listed below.
 *   +------+----------------------+
 *   | size | field                |
 *   +------+----------------------+
 *   | 4    | size                 |
 *   | 4    | type = 'ftyp'        |
 *   +------+----------------------+
 *   | 4    | major_brand = 'qt  ' |
 *   | 4    | minor_version        |
 *   |      | compatible_brands 1  |
 *    ...
 *   |      | compatible_brands N  |
 *   +------+----------------------+
 * @extends {mov::Atom}
 */
struct FileTypeAtom {
  // mov::Atom methods.
  const uint8_t* GetData() const { return base_.GetData(); }
  uint32_t GetSize() const { return base_.GetSize(); }
  FourCC GetType() const { return base_.GetType(); }
  const uint8_t* GetNext() const { return base_.GetNext(); }

  /**
   * Retrieves the brand ID.
   * @return {mov::FourCC}
   * @private
   */
  FourCC LoadBrand(const uint8_t* p) const {
    return static_cast<FourCC>(CPU::LoadUINT32(p));
  }

  /**
   * Returns whether or not this atom is a valid file-type atom.
   * @return {int}
   * @public
   */
  int IsValid() const;

  /**
   * The base object.
   * @type {mov::Atom}
   * @private
   */
  Atom base_;

  /**
   * The major brand (format) ID. (This field must be 'qt  ' for QuickTime movie
   * files.)
   * @type {uint32_t}
   * @private
   */
  uint32_t major_brand_;

  /**
   * The format-specification version. (For QuickTime movie files, this field
   * is four binary-coded decimal values representing a century, a year, a
   * month, and a reserved field. For example, '0x20, 0x04, 0x06, 0x00'
   * represents 'June, 2004'.)
   * @type {uint32_t}
   * @private
   */
  uint32_t minor_version_;

  /**
   * The compatible format IDs.
   * @type {uint32_t[]}
   * @private
   */
  uint32_t compatible_brands_[0];
};

/**
 * The class that represents a QuickTime Movie-Header atom, a 108-byte QuickTime
 * atom listed below.
 *   +------+----------------------+
 *   | size | field                |
 *   +------+----------------------+
 *   | 4    | size                 |
 *   | 4    | type = 'mvhd'        |
 *   +------+----------------------+
 *   | 1    | version              |
 *   | 3    | flags                |
 *   | 4    | creation time        |
 *   | 4    | modification time    |
 *   | 4    | time scale           |
 *   | 4    | duration             |
 *   | 4    | preferred rate       |
 *   | 2    | preferred volume     |
 *   | 10   | reserved             |
 *   | 36   | matrix structure     |
 *   | 4    | preview time         |
 *   | 4    | preview duration     |
 *   | 4    | poster time          |
 *   | 4    | selection time       |
 *   | 4    | selection duration   |
 *   | 4    | current time         |
 *   | 4    | next track ID        |
 *   +------+----------------------+
 * @extends {mov::Atom}
 */
struct MovieHeaderAtom {
  // mov::Atom methods.
  const uint8_t* GetData() const { return base_.GetData(); }
  uint32_t GetSize() const { return base_.GetSize(); }
  FourCC GetType() const { return base_.GetType(); }
  const uint8_t* GetNext() const { return base_.GetNext(); }

  /**
   * The base object.
   * @type {mov::Atom}
   * @private
   */
  Atom base_;

  /**
   * The version of this movie-header atom.
   * @type {uint8_t}
   * @private
   */
  uint8_t version_;

  /**
   * Reserved. (This field must be zero.)
   * @type {uint8_t[3]}
   * @private
   */
  uint8_t flags_[3];

  /**
   * The creation time of this movie. (the number of seconds since midnight,
   * 1 Jan, 1904).
   * @type {uint32_t}
   * @private
   */
  uint32_t creation_times_;

  /**
   * The creation time of this movie. (the number of seconds since midnight,
   * 1 Jan, 1904).
   * @type {uint32_t}
   * @private
   */
  uint32_t modification_times_;

  /**
   * The time scale of this movie.
   * @type {uint32_t}
   * @private
   */
  uint32_t time_scale_;

  /**
   * The duration of this movie (in time-scale units).
   * @type {uint32_t}
   * @private
   */
  uint32_t duration_;

  /**
   * The preferred rate to play this movie.
   * @type {uint32_t}
   * @private
   */
  uint32_t preferred_rate_;

  /**
   * The preferred volume to play this movie.
   * @type {uint16_t}
   * @private
   */
  uint16_t preferred_volume_;

  /**
   * Reserved. (This field must be zero.)
   * @type {uint8_t[10]}
   * @private
   */
  uint8_t reserved_[10];

  /**
   * The display matrix.
   * @type {uint32_t[9]}
   * @private
   */
  uint32_t matrix_[9];

  /**
   * The time when the movie preview starts.
   * @type {uint32_t}
   * @private
   */
  uint32_t preview_time_;

  /**
   * The duration of the movie preview.
   * @type {uint32_t}
   * @private
   */
  uint32_t preview_duration_;

  /**
   * The time when the movie poster starts.
   * @type {uint32_t}
   * @private
   */
  uint32_t poster_time_;

  /**
   * The start time of the current selection.
   * @type {uint32_t}
   * @private
   */
  uint32_t selection_time_;

  /**
   * The duration of the current selection.
   * @type {uint32_t}
   * @private
   */
  uint32_t selection_duration_;

  /**
   * The current time position.
   * @type {uint32_t}
   * @private
   */
  uint32_t current_time_;

  /**
   * The ID of the next track.
   * @type {uint32_t}
   * @private
   */
  uint32_t next_track_id_;
};

/**
 * The class that represents a QuickTime track-header atom, a 86-byte QuickTime
 * atom listed below.
 *   +------+----------------------+
 *   | size | field                |
 *   +------+----------------------+
 *   | 4    | size                 |
 *   | 4    | type = 'tkhd'        |
 *   +------+----------------------+
 *   | 1    | version              |
 *   | 3    | flags                |
 *   | 4    | creation time        |
 *   | 4    | modification time    |
 *   | 4    | track ID             |
 *   | 4    | reserved             |
 *   | 4    | duration             |
 *   | 4    | reserved             |
 *   | 2    | layer                |
 *   | 2    | alternate group      |
 *   | 2    | volume               |
 *   | 2    | reserved             |
 *   | 36   | matrix structure     |
 *   | 4    | track width          |
 *   | 4    | track height         |
 *   +------+----------------------+
 * @extends {mov::Atom}
 */
struct TrackHeaderAtom {
  // mov::Atom methods.
  const uint8_t* GetData() const { return base_.GetData(); }
  uint32_t GetSize() const { return base_.GetSize(); }
  FourCC GetType() const { return base_.GetType(); }
  const uint8_t* GetNext() const { return base_.GetNext(); }

  /**
   * The base object.
   * @type {mov::Atom}
   * @private
   */
  Atom base_;

  /**
   * The version of this movie-header atom.
   * @type {uint8_t}
   * @private
   */
  uint8_t version_;

  /**
   * Reserved. (This field must be zero.)
   * @type {uint8_t[3]}
   * @private
   */
  uint8_t flags_[3];

  /**
   * The creation time of this movie. (the number of seconds since midnight,
   * 1 Jan, 1904).
   * @type {uint32_t}
   * @private
   */
  uint32_t creation_times_;

  /**
   * The creation time of this movie. (the number of seconds since midnight,
   * 1 Jan, 1904).
   * @type {uint32_t}
   * @private
   */
  uint32_t modification_times_;

  /**
   * The track ID.
   * @type {uint32_t}
   * @private
   */
  uint32_t track_id_;

  /**
   * The reserved for Apple. (This field must be zero.)
   * @type {uint32_t}
   * @private
   */
  uint32_t reserved0_;

  /**
   * The duration of this movie (in time-scale units).
   * @type {uint32_t}
   * @private
   */
  uint32_t duration_;

  /**
   * Reserved. (This field must be zero.)
   * @type {uint32_t}
   * @private
   */
  uint32_t reserved1_;

  /**
   * The layer used by the QuickTime Movie toolbox.
   * @type {uint16_t}
   * @private
   */
  uint16_t layer_;

  /**
   * The collection of alternate movie tracks.
   * @type {uint16_t}
   * @private
   */
  uint16_t alternate_group_;

  /**
   * The volume.
   * @type {uint16_t}
   * @private
   */
  uint16_t volume_;

  /**
   * Reserved. (This field must be zero.)
   * @type {uint16_t}
   * @private
   */
  uint16_t reserved2_;

  /**
   * The display matrix.
   * @type {uint32_t[9]}
   * @private
   */
  uint32_t matrix_[9];

  /**
   * The track width (in pixels.)
   * @type {uint32_t}
   * @private
   */
  uint32_t track_width_;

  /**
   * The track height (in pixels.)
   * @type {uint32_t}
   * @private
   */
  uint32_t track_height_;
};

/**
 * The class that represents a QuickTime Media-Header atom, a 32-byte QuickTime
 * atom listed below.
 *   +------+----------------------+
 *   | size | field                |
 *   +------+----------------------+
 *   | 4    | size                 |
 *   | 4    | type = 'mdhd'        |
 *   +------+----------------------+
 *   | 1    | version              |
 *   | 3    | flags                |
 *   | 4    | creation time        |
 *   | 4    | modification time    |
 *   | 4    | time scale           |
 *   | 4    | duration             |
 *   | 2    | language             |
 *   | 2    | quality              |
 *   +------+----------------------+
 * @extends {mov::Atom}
 */
struct MediaHeaderAtom {
  // mov::Atom methods.
  const uint8_t* GetData() const { return base_.GetData(); }
  uint32_t GetSize() const { return base_.GetSize(); }
  FourCC GetType() const { return base_.GetType(); }
  const uint8_t* GetNext() const { return base_.GetNext(); }

  /**
   * Returns the size of this atom.
   * @return {uint32_t}
   * @public
   */
  uint32_t GetCreationTime() const {
    return CPU::LoadUINT32BE(&creation_time_);
  }

  /**
   * Returns the size of this atom.
   * @return {uint32_t}
   * @public
   */
  uint32_t GetModificationTime() const {
    return CPU::LoadUINT32BE(&modification_time_);
  }

  /**
   * Returns the size of this atom.
   * @return {uint32_t}
   * @public
   */
  uint32_t GetTimeScale() const {
    return CPU::LoadUINT32BE(&time_scale_);
  }

  /**
   * Returns the size of this atom.
   * @return {uint32_t}
   * @public
   */
  uint32_t GetDuration() const {
    return CPU::LoadUINT32BE(&duration_);
  }

  /**
   * The base object.
   * @type {mov::Atom}
   * @private
   */
  Atom base_;

  /**
   * The version of this movie-header atom.
   * @type {uint8_t}
   * @private
   */
  uint8_t version_;

  /**
   * Reserved. (This field must be zero.)
   * @type {uint8_t[3]}
   * @private
   */
  uint8_t flags_[3];

  /**
   * The creation time of this media. (the number of seconds since midnight,
   * 1 Jan, 1904).
   * @type {uint32_t}
   * @private
   */
  uint32_t creation_time_;

  /**
   * The creation time of this media. (the number of seconds since midnight,
   * 1 Jan, 1904).
   * @type {uint32_t}
   * @private
   */
  uint32_t modification_time_;

  /**
   * The time scale of this media.
   * @type {uint32_t}
   * @private
   */
  uint32_t time_scale_;

  /**
   * The duration of this media (in time-scale units).
   * @type {uint32_t}
   * @private
   */
  uint32_t duration_;

  /**
   * The language ID for this media.
   * @type {uint32_t}
   * @private
   */
  uint32_t language_;

  /**
   * The media-playback quality.
   * @type {uint16_t}
   * @private
   */
  uint16_t quality_;
};

/**
 * The class that represents a sample description, a chunk object starting with
 * a 16-byte header listed below.
 *   +------+----------------------+
 *   | size | field                |
 *   +------+----------------------+
 *   | 4    | size                 |
 *   | 4    | format               |
 *   +------+----------------------+
 *   | 6    | reserved             |
 *   | 2    | data reference index |
 *   +------+----------------------+
 *   |      | format-specific data |
 *   +------+----------------------+
 * @extends {mov::Atom}
 */
struct SampleDescription {
  // mov::Atom methods.
  const uint8_t* GetData() const { return base_.GetData(); }
  uint32_t GetSize() const { return base_.GetSize(); }
  FourCC GetType() const { return base_.GetType(); }
  const uint8_t* GetNext() const { return base_.GetNext(); }

  /**
   * Retrieves the next sample description.
   * @return {const mov::SampleDescription*}
   * @public
   */
  const SampleDescription* GetNextDescription() const {
    return reinterpret_cast<const SampleDescription*>(GetNext());
  }

  /**
   * Retrieves the video sample description.
   * @return {const mov::VideoSampleDescription*}
   * @public
   */
  const VideoSampleDescription* GetVideoSampleDescription() const {
    return reinterpret_cast<const VideoSampleDescription*>(this);
  }

  /**
   * The description size.
   * @type {mov::Atom}
   * @private
   */
  Atom base_;

  /**
   * The reserved area.
   * @type {uint8_t[6]}
   * @private
   */
  uint8_t reserved_[6];

  /**
   * The index of the data reference to use to retrieve data associated with
   * samples that use this sample description.
   * @type {uint32_t}
   * @private
   */
  uint8_t index_[2];
};

/**
 * The class that represents a video sample description extension, a chunk
 * object starting with an eight-byte header listed below.
 *   +------+----------------------+
 *   | size | field                |
 *   +------+----------------------+
 *   | 4    | size                 |
 *   | 4    | type                 |
 *   +------+----------------------+
 *   |      | type-specific data   |
 *   +------+----------------------+
 * @extends {mov::Atom}
 */
struct VideoSampleDescriptionExtension {
  // mov::Atom methods.
  const uint8_t* GetData() const { return base_.GetData(); }
  uint32_t GetSize() const { return base_.GetSize(); }
  FourCC GetType() const { return base_.GetType(); }
  const uint8_t* GetNext() const { return base_.GetNext(); }

  /**
   * Retrieves the next sample description.
   * @return {const mov::SampleDescription*}
   * @public
   */
  const uint8_t* GetExtraData() const {
    return &extra_data_[0];
  }

  /**
   * Retrieves the size of the extension-specific data.
   * @return {size_t}
   * @public
   */
  size_t GetExtraSize() const {
    return static_cast<size_t>(GetNext() - &extra_data_[0]);
  }

  /**
   * The base object.
   * @type {mov::Atom}
   * @private
   */
  Atom base_;

  /**
   * The extension-specific data.
   * @type {uint8_t[]}
   * @private
   */
  uint8_t extra_data_[0];
};

/**
 * The class that represents a video sample description, a 86-byte sample
 * description listed below.
 *   +------+-----------------------+
 *   | size | field                 |
 *   +------+-----------------------+
 *   | 4    | size                  |
 *   | 4    | format                |
 *   | 6    | reserved              |
 *   | 2    | data reference index  |
 *   +------+-----------------------+
 *   | 2    | version               |
 *   | 2    | revision level = 0    |
 *   | 4    | vendor                |
 *   | 4    | temporal quality      |
 *   | 4    | spatial quality       |
 *   | 2    | width                 |
 *   | 2    | height                |
 *   | 4    | horizontal resolution |
 *   | 4    | vertical resolution   |
 *   | 4    | data size = 0         |
 *   | 2    | frame count = 1       |
 *   | 32   | compressor name       |
 *   | 2    | depth                 |
 *   | 2    | color table ID        |
 *   +------+-----------------------+
 * @extends {mov::SampleDescription}
 */
struct VideoSampleDescription {
  // mov::SampleDescription methods.
  const uint8_t* GetData() const { return base_.GetData(); }
  uint32_t GetSize() const { return base_.GetSize(); }
  FourCC GetType() const { return base_.GetType(); }
  const uint8_t* GetNext() const { return base_.GetNext(); }
  const SampleDescription* GetNextDescription() const { return base_.GetNextDescription(); }

  /**
   * Returns the vendor ID.
   * @return {mov::FourCC}
   * @public
   */
  FourCC GetVendor() const {
    return static_cast<FourCC>(CPU::LoadUINT32(&vendor_));
  }

  /**
   * Returns the frame width.
   * @return {uint16_t}
   * @public
   */
  uint16_t GetWidth() const {
    return CPU::LoadUINT16BE(&width_);
  }

  /**
   * Returns the frame height.
   * @return {uint16_t}
   * @public
   */
  uint16_t GetHeight() const {
    return CPU::LoadUINT16BE(&height_);
  }

  /**
   * Returns the beginning of the extra data.
   * @return {const uint8_t*}
   * @public
   */
  const uint8_t* GetExtraData() const {
    return &extra_data_[0];
  }

  /**
   * Retrieve the extension at the specified index.
   * @param {const uint8_t*} data
   * @return {const VideoSampleDescriptionExtension*}
   */
  const VideoSampleDescriptionExtension* GetExtension(
      const uint8_t* data) const {
    return reinterpret_cast<const VideoSampleDescriptionExtension*>(data);
  }

  /**
   * The base object.
   * @type {mov::SampleDescription}
   * @private
   */
  SampleDescription base_;

  /**
   * The version number of the compressed data.
   * @type {uint16_t}
   * @private
   */
  uint16_t version_;

  /**
   * The revision level. (This field must be 0.)
   * @type {uint16_t}
   * @private
   */
  uint16_t revision_level_;

  /**
   * The compressor vendor.
   * @type {uint32_t}
   * @private
   */
  uint32_t vendor_;

  /**
   * The temporal compression quality (from 0 to 1023).
   * @type {uint32_t}
   * @private
   */
  uint32_t temporal_quality_;

  /**
   * The spatial compression quality (from 0 to 1024).
   * @type {uint32_t}
   * @private
   */
  uint32_t spatial_quality_;

  /**
   * The frame width.
   * @type {uint16_t}
   * @private
   */
  uint16_t width_;

  /**
   * The frame height.
   * @type {uint16_t}
   * @private
   */
  uint16_t height_;

  /**
   * The horizontal resolution of video frames.
   * @type {uint32_t}
   * @private
   */
  uint32_t horizontal_resolution_;

  /**
   * The vertical resolution of video frames.
   * @type {uint32_t}
   * @private
   */
  uint32_t vertical_resolution_;

  /**
   * The data size. (This field must be 0).
   * @type {uint32_t}
   * @private
   */
  uint32_t data_size_;

  /**
   * The number of frames in each sample. (This field is usually 1.)
   * @type {uint16_t}
   * @private
   */
  uint16_t frame_count_;

  /**
   * The name of the compressor (in Pascal string).
   * @type {uint8_t[32]}
   * @private
   */
  uint8_t compressor_name_[32];

  /**
   * The color depth.
   * @type {uint16_t}
   * @private
   */
  uint16_t depth_;

  /**
   * The color table.
   * @type {uint16_t}
   * @private
   */
  uint16_t color_table_;

  /**
   * The extra data.
   * @type {uint8_t[]}
   * @private
   */
  uint8_t extra_data_[0];
};

/**
 * The class that represents a QuickTime Sample Description atom, a variable-
 * length QuickTime atom representing an array of sample descriptions as listed
 * below.
 *   +------+-----------------------+
 *   | size | field                 |
 *   +------+-----------------------+
 *   | 4    | size                  |
 *   | 4    | type = 'stsd'         |
 *   +------+-----------------------+
 *   | 1    | version               |
 *   | 3    | flags                 |
 *   | 4    | number of entries     |
 *   +------+-----------------------+
 *   |      | sample description #1 |
 *   +------+-----------------------+
 *    ...
 *   +------+-----------------------+
 *   |      | sample description #n |
 *   +------+-----------------------+
 * @extends {mov::Atom}
 */
struct SampleDescriptionAtom {
  // mov::Atom methods.
  const uint8_t* GetData() const { return base_.GetData(); }
  uint32_t GetSize() const { return base_.GetSize(); }
  FourCC GetType() const { return base_.GetType(); }
  const uint8_t* GetNext() const { return base_.GetNext(); }

  /**
   * Returns the number of sample descriptions in this array.
   * @return {uint32_t}
   * @public
   */
  uint32_t GetCount() const {
    return CPU::LoadUINT32BE(&number_of_entries_);
  }

  /**
   * Retrieves the first sample description in this array.
   * @return {const mov::SampleDescription*}
   * @public
   */
  const SampleDescription* GetFirstDescription() const {
    return &sample_descriptions_[0];
  }

  /**
   * The base object.
   * @type {mov::Atom}
   * @private
   */
  Atom base_;

  /**
   * The version of this sample-description atom.
   * @type {uint8_t}
   * @private
   */
  uint8_t version_[1];

  /**
   * Reserved. (This field must be zero.)
   * @type {uint8_t[3]}
   * @private
   */
  uint8_t flags_[3];

  /**
   * Returns the number of sample descriptions in the sample-description table.
   * @type {uint32_t}
   * @private
   */
  uint32_t number_of_entries_;

  /**
   * The sample-description table.
   * @type {mov::SampleDescription[]}
   * @private
   */
  SampleDescription sample_descriptions_[0];
};

/**
 * The class that represents a QuickTime Time-to-Sample atom, a variable-length
 * QuickTime atom representing an array of samples as listed below.
 *   +------+----------------------+
 *   | size | field                |
 *   +------+----------------------+
 *   | 4    | size                 |
 *   | 4    | type = 'stts'        |
 *   +------+----------------------+
 *   | 1    | version              |
 *   | 3    | flags                |
 *   | 4    | number of entries    |
 *   +------+----------------------+
 *   | 8    | time-to-sample #1    |
 *   +------+----------------------+
 *    ...
 *   +------+----------------------+
 *   | 8    | time-to-sample #n    |
 *   +------+----------------------+
 * @extends {mov::Atom}
 */
struct TimeToSampleAtom {
  /**
   * The class encapsulating an sample-to-chunk table entry.
   */
  struct Entry {
    /**
     * Returns the number of consecutive samples.
     * @return {uint32_t}
     * @public
     */
    uint32_t GetCount() const {
      return CPU::LoadUINT32BE(&sample_count_);
    }

    /**
     * Returns the sample duration.
     * @return {uint32_t}
     * @public
     */
    uint32_t GetDuration() const {
      return CPU::LoadUINT32BE(&sample_duration_);
    }

    /**
     * Returns the sample duration in seconds.
     * @param {float} time_scale
     * @return {float}
     * @public
     */
    float GetDurationInSeconds(float time_scale) const {
      return static_cast<float>(GetDuration()) / time_scale;
    }

    /**
     * The number of consecutive samples that have the same duration.
     * @type {uint32_t}
     * @private
     */
    uint32_t sample_count_;

    /**
     * The duration of this sample.
     * @type {uint32_t}
     * @private
     */
    uint32_t sample_duration_;
  };

  // mov::Atom methods.
  const uint8_t* GetData() const { return base_.GetData(); }
  uint32_t GetSize() const { return base_.GetSize(); }
  FourCC GetType() const { return base_.GetType(); }
  const uint8_t* GetNext() const { return base_.GetNext(); }

  /**
   * Returns the number of sample-to-chunk entries in the sample-to-chunk table.
   * @return {uint32_t}
   * @public
   */
  uint32_t GetCount() const {
    return CPU::LoadUINT32BE(&number_of_entries_);
  }

  /**
   * Returns the `index`-th entry of the time-to-sample table.
   * @return {const mov::TimeToSampleAtom::Entry*}
   * @public
   */
  const Entry* GetEntry(int index) const {
    return &entries_[index];
  }

  /**
   * The base object.
   * @type {mov::Atom}
   * @private
   */
  Atom base_;

  /**
   * The version of this movie-header atom.
   * @type {uint8_t}
   * @private
   */
  uint8_t version_;

  /**
   * Reserved. (This field must be zero.)
   * @type {uint8_t[3]}
   * @private
   */
  uint8_t flags_[3];

  /**
   * The number of entries in the sample-to-chunk table.
   * @type {uint32_t}
   * @private
   */
  uint32_t number_of_entries_;

  /**
   * The sample-to-chunk table.
   * @type {mov::TimeToSampleAtom::Entry[]}
   * @private
   */
  Entry entries_[0];
};

/**
 * The class that represents a QuickTime Sync Sample atom, a variable-length
 * QuickTime atom representing an array of key frames as listed below.
 *   +------+----------------------+
 *   | size | field                |
 *   +------+----------------------+
 *   | 4    | size                 |
 *   | 4    | type = 'stss'        |
 *   +------+----------------------+
 *   | 1    | version              |
 *   | 3    | flags                |
 *   | 4    | number of entries    |
 *   +------+----------------------+
 *   | 4    | sync sample #1       |
 *   +------+----------------------+
 *    ...
 *   +------+----------------------+
 *   | 4    | sync sample #n       |
 *   +------+----------------------+
 * @extends {mov::Atom}
 */
struct SyncSampleAtom {
  // mov::Atom methods.
  const uint8_t* GetData() const { return base_.GetData(); }
  uint32_t GetSize() const { return base_.GetSize(); }
  FourCC GetType() const { return base_.GetType(); }
  const uint8_t* GetNext() const { return base_.GetNext(); }

  /**
   * Returns the number of sample-to-chunk entries in the sample-to-chunk table.
   * @return {uint32_t}
   * @public
   */
  uint32_t GetCount() const {
    return CPU::LoadUINT32BE(&number_of_entries_);
  }

  /**
   * Returns the `index`-th sync-sample number of the sync-sample table.
   * @return {uint32_t}
   * @public
   */
  uint32_t GetSyncSample(int index) const {
    return CPU::LoadUINT32BE(&sync_samples_[index]);
  }

  /**
   * The base object.
   * @type {mov::Atom}
   * @private
   */
  Atom base_;

  /**
   * The version of this movie-header atom.
   * @type {uint8_t}
   * @private
   */
  uint8_t version_;

  /**
   * Reserved. (This field must be zero.)
   * @type {uint8_t[3]}
   * @private
   */
  uint8_t flags_[3];

  /**
   * The number of entries in the sample-to-chunk table.
   * @type {uint32_t}
   * @private
   */
  uint32_t number_of_entries_;

  /**
   * The sync-sample table.
   * @type {uint32_t}
   * @private
   */
  uint32_t sync_samples_[0];
};

/**
 * The class that represents a QuickTime Sample-to-Chunk atom, a variable-length
 * atom representing an array of chunks (an array of samples) as listed below.
 *   +------+----------------------+
 *   | size | field                |
 *   +------+----------------------+
 *   | 4    | size                 |
 *   | 4    | type = 'stsc'        |
 *   +------+----------------------+
 *   | 1    | version              |
 *   | 3    | flags                |
 *   | 4    | sample size          |
 *   | 4    | number of entries    |
 *   +------+----------------------+
 *   | 12   | sample-to-chunk #1   |
 *   +------+----------------------+
 *    ...
 *   +------+----------------------+
 *   | 12   | sample-to-chunk #n   |
 *   +------+----------------------+
 * @extends {mov::Atom}
 */
struct SampleToChunkAtom {
  /**
   * The class encapsulating an sample-to-chunk table entry.
   */
  struct Entry {
    /**
     * Returns the first chunk number.
     * @return {uint32_t}
     * @public
     */
    uint32_t GetFirst() const {
      return CPU::LoadUINT32BE(&first_chunk_);
    }

    /**
     * Returns the number of samples in this chunk.
     * @return {uint32_t}
     * @public
     */
    uint32_t GetSamples() const {
      return CPU::LoadUINT32BE(&samples_per_chunk_);
    }

    /**
     * Returns the sample-description ID.
     * @return {uint32_t}
     * @public
     */
    uint32_t GetDescription() const {
      return CPU::LoadUINT32BE(&sample_description_id_);
    }

    /**
     * The first chunk number.
     * @type {uint32_t}
     * @private
     */
    uint32_t first_chunk_;

    /**
     * The number of samples in this chunk.
     * @type {uint32_t}
     * @private
     */
    uint32_t samples_per_chunk_;

    /**
     * The sample-description ID.
     * @type {uint32_t}
     * @private
     */
    uint32_t sample_description_id_;
  };

  // mov::Atom methods.
  const uint8_t* GetData() const { return base_.GetData(); }
  uint32_t GetSize() const { return base_.GetSize(); }
  FourCC GetType() const { return base_.GetType(); }
  const uint8_t* GetNext() const { return base_.GetNext(); }

  /**
   * Returns the number of sample-to-chunk entries in the sample-to-chunk table.
   * @return {uint32_t}
   * @public
   */
  uint32_t GetCount() const {
    return CPU::LoadUINT32BE(&number_of_entries_);
  }

  /**
   * Returns the `index`-th entry of the sample-to-chunk table.
   * @return {const mov::SampleToChunkAtom::Entry*}
   * @public
   */
  const Entry* GetEntry(int index) const {
    return &entries_[index];
  }

  /**
   * Returns the array of sample-to-chunk entries.
   * @return {const mov::SampleToChunkAtom::Entry*}
   * @public
   */
  const Entry* GetEntries() const {
    return &entries_[0];
  }

  /**
   * The base object.
   * @type {mov::Atom}
   * @private
   */
  Atom base_;

  /**
   * The version of this movie-header atom.
   * @type {uint8_t}
   * @private
   */
  uint8_t version_;

  /**
   * Reserved. (This field must be zero.)
   * @type {uint8_t[3]}
   * @private
   */
  uint8_t flags_[3];

  /**
   * The number of entries in the sample-to-chunk table.
   * @type {uint32_t}
   * @private
   */
  uint32_t number_of_entries_;

  /**
   * The sample-to-chunk table.
   * @type {mov::SampleToChunkAtom::Entry[]}
   * @private
   */
  Entry entries_[0];
};

/**
 * The class that represents a QuickTime Sample Size atom, a variable-length
 * QuickTime atom representing an array of sample sizes as listed below.
 *   +------+----------------------+
 *   | size | field                |
 *   +------+----------------------+
 *   | 4    | size                 |
 *   | 4    | type = 'stsz'        |
 *   +------+----------------------+
 *   | 1    | version              |
 *   | 3    | flags                |
 *   | 4    | sample size          |
 *   | 4    | number of entries    |
 *   +------+----------------------+
 *   | 4    | sample size #1       |
 *   +------+----------------------+
 *    ...
 *   +------+----------------------+
 *   | 4    | sample size #n       |
 *   +------+----------------------+
 * @extends {mov::Atom}
 */
struct SampleSizeAtom {
  // mov::Atom methods.
  const uint8_t* GetData() const { return base_.GetData(); }
  uint32_t GetSize() const { return base_.GetSize(); }
  FourCC GetType() const { return base_.GetType(); }
  const uint8_t* GetNext() const { return base_.GetNext(); }

  /**
   * Returns the constant sample-size.
   * @return {uint32_t}
   * @public
   */
  uint32_t GetSampleSize() const {
    return CPU::LoadUINT32BE(&sample_size_);
  }

  /**
   * Returns the number of sample sizes in the sample-size table.
   * @return {uint32_t}
   * @public
   */
  uint32_t GetCount() const {
    return CPU::LoadUINT32BE(&number_of_entries_);
  }

  /**
   * Returns the `index`-th sample size of the sample-size table.
   * @return {uint32_t}
   * @public
   */
  uint32_t GetSampleSize(int index) const {
    return CPU::LoadUINT32BE(&sample_sizes_[index]);
  }

  /**
   * The base object.
   * @type {mov::Atom}
   * @private
   */
  Atom base_;

  /**
   * The version of this movie-header atom.
   * @type {uint8_t}
   * @private
   */
  uint8_t version_;

  /**
   * Reserved. (This field must be zero.)
   * @type {uint8_t[3]}
   * @private
   */
  uint8_t flags_[3];

  /**
   * The sample size if all samples are the size size.
   * @type {uint32_t}
   * @private
   */
  uint32_t sample_size_;

  /**
   * The number of entries in the chunk-offset table.
   * @type {uint32_t}
   * @private
   */
  uint32_t number_of_entries_;

  /**
   * The sample-size table.
   * @type {uint32_t[]}
   * @private
   */
  uint32_t sample_sizes_[0];
};

/**
 * The class that represents a QuickTime chunk-offset atom, a variable-length
 * QuickTime atom representing an array of chunk offsets as listed below.
 *   +------+----------------------+
 *   | size | field                |
 *   +------+----------------------+
 *   | 4    | size                 |
 *   | 4    | type = 'stco'        |
 *   +------+----------------------+
 *   | 1    | version              |
 *   | 3    | flags                |
 *   | 4    | number of entries    |
 *   +------+----------------------+
 *   | 4    | chunk offset #1      |
 *   +------+----------------------+
 *    ...
 *   +------+----------------------+
 *   | 4    | chunk offset #n      |
 *   +------+----------------------+
 * @extends {mov::Atom}
 */
struct ChunkOffsetAtom {
  // mov::Atom methods.
  const uint8_t* GetData() const { return base_.GetData(); }
  uint32_t GetSize() const { return base_.GetSize(); }
  FourCC GetType() const { return base_.GetType(); }
  const uint8_t* GetNext() const { return base_.GetNext(); }

  /**
   * Returns the number of chunk offsets in the chunk-offset table.
   * @return {uint32_t}
   * @public
   */
  uint32_t GetCount() const {
    return CPU::LoadUINT32BE(&number_of_entries_);
  }

  /**
   * Returns the `index`-th offset of the sample-to-chunk table.
   * @return {uint32_t}
   * @public
   */
  const uint32_t GetOffset(int index) const {
    return CPU::LoadUINT32BE(&chunk_offsets_[index]);
  }

  /**
   * The base object.
   * @type {mov::Atom}
   * @private
   */
  Atom base_;

  /**
   * The version of this movie-header atom.
   * @type {uint8_t}
   * @private
   */
  uint8_t version_;

  /**
   * Reserved. (This field must be zero.)
   * @type {uint8_t[3]}
   * @private
   */
  uint8_t flags_[3];

  /**
   * The number of entries in the chunk-offset table.
   * @type {uint32_t}
   * @private
   */
  uint32_t number_of_entries_;

  /**
   * The chunk-offset table.
   * @type {uint32_t[]}
   * @private
   */
  uint32_t chunk_offsets_[0];
};

#pragma pack(pop)

}  // namespace mov

#endif  // MOV_ATOM_H_
